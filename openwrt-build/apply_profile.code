#!/bin/sh

log()
{
	echo "$0: $1" >/dev/console
	logger -s -- "$0: $1"
	true
}

uptime_in_seconds()
{
	cut -d'.' -f1 /proc/uptime
}

has_default_route()
{
	local interface="${1:-.}"	# empty = dot = always match, no matter which interface

	route -n | grep ^'0\.0\.0\.0' | grep -q "$interface" && return 0

	ip route list exact '0.0.0.0/0' | grep ^'default' | grep -q "$interface"
}

password_was_never_set()
{
	grep -qs ^'root::' /etc/shadow && return 0
	grep -qs ^'root:[!x]\?:' /etc/shadow
}

password_set()
{
	local PASSWORD="${1:-admin}"
	local config_uhttpd='/etc/httpd.conf'
	local credentials

	# not needed when applied 0001-base-files-allow-telnet-login-without-password.patch
	grep -q 'read -r PASS' '/bin/login.sh' || {
		command -v dropbear >/dev/null || {
			log "missing dropbear, allowing telnet login permanently in /bin/login.sh"
			sed -i 's/exit 0/# exit 0/' /bin/login.sh
		}
	}

	[ -e "$config_uhttpd" ] || {
		echo "/cgi-bin/:root:$PASSWORD" >"$config_uhttpd"

		for credentials in $HTTPD_CREDENTIALS; do {
			echo "/cgi-bin/:$credentials" >>"$config_uhttpd"
		} done
	}

	password_was_never_set || {
		log "password_set() ignore call, password already set"
		return 0
	}

	log "password_set() to '$PASSWORD'"
	sh -c "echo '$PASSWORD'; sleep 1; echo '$PASSWORD'" | passwd>/dev/null 2>&1
	log "password_set() [OK]"
}

jffs2_is_ready()
{
	local message="$1"
	local funcname='jffs2_is_ready'
	local pattern='jffs2_build_xattr_subsystem: complete building xattr subsystem'
	local markerfile="/tmp/$funcname"

	is_ok()
	{
		touch "$markerfile"
		log "[OK] $funcname() $message"
	}

	if   [ -e "$markerfile" ]; then
		return 0
	elif [ -n "$FAILSAFE" ]; then
		is_ok 'failsafe mode active'
	elif grep -q '=ext[2-4]' '/proc/cmdline'; then
		is_ok 'rootfs = ext-FS'
	elif grep -q '=/dev/mmcblk' '/proc/cmdline'; then
		is_ok 'rootfs = SD-card'
	elif grep -q ^'/dev/root / ext[2-4] ' '/proc/mounts'; then
		is_ok 'rootfs = ext-FS'
	elif grep -q "$pattern" "$DMESG"; then
		is_ok 'found ready marker in klog'
	elif grep -q ^'overlayfs:/overlay ' /proc/mounts; then
		# TODO: check if tmpfs or real
		# e.g.: ready
		# /dev/mtdblock8 /overlay jffs2 rw,noatime 0 0
		# overlayfs:/overlay / overlay rw,noatime,lowerdir=/,upperdir=/overlay/upper,workdir=/overlay/work 0 0
		is_ok 'overlayfs mounted'
	elif [ ! -e '/etc/init.d/apply_profile' ]; then
		is_ok 'already applied profile, filesystem should be ok'
	else
		[ $( uptime_in_seconds ) -gt 240 ] && {
			is_ok 'uptime >4 min'
		}
	fi

	if [ -e "$markerfile" ]; then
		return 0
	else
		log "[ERR] $funcname() does not seems ready yet: $( uptime )"
		return 1
	fi
}

find_all_strings_in_dmesg()
{
	local error

	while [ -n "$1" ]; do {
		if grep -Fq "$1" "$DMESG"; then
			error=0
		else
			error=1
		fi

		shift
	} done

	return $error
}

hwprobe()
{
	local machine="$1"

	case "$machine" in
		"D-Link DIR-300 RevA1")
			find_all_strings_in_dmesg	"CPU revision is: 00019064 (MIPS 4KEc)" \
							"ath5k: phy0: Atheros AR2317 chip found (MAC: 0x90, PHY: 0x48)" \
							"IP17xx: Found IP175C at 0:00"
		;;
		"Ubiquiti Nanostation2")
			find_all_strings_in_dmesg	"CPU revision is: 00019064 (MIPS 4KEc)" \
							"ath5k: phy0: Atheros AR2315 chip found (MAC: 0x86, PHY: 0x48)" \
							"lpj=918528"
		;;
		"Ubiquiti PicoStation2")
			find_all_strings_in_dmesg	"CPU revision is: 00019064 (MIPS 4KEc)" \
							"ath5k phy0: Atheros AR2317 chip found (MAC: 0x90, PHY: 0x48)" \
							"lpj=917504"
		;;
		"Ubiquiti Nanostation5")
			find_all_strings_in_dmesg	"CPU revision is: 0001800a (MIPS 4Kc)" \
							"ath5k: phy0: Atheros AR2313 chip found (MAC: 0x58, PHY: 0x44)" \
							"lpj=898048"
		;;
		"Ubiquiti PicoStation5"|"Ubiquiti Litestation5")	# nanostation5 -> lpj differs
			find_all_strings_in_dmesg	"CPU revision is: 0001800a (MIPS 4Kc)" \
							"ath5k phy0: Atheros AR2313 chip found (MAC: 0x58, PHY: 0x44)" \
							"lpj=899072"
		;;
		*)
			false
		;;
	esac

	return $?
}

uboot_getvar()
{
	local var="$1"

	strings '/dev/mtd0' | grep ^"${var}=" | cut -d'=' -f2
}

try_device()
{
	I=$(( ${I:=0} + 1 ))	# global_var

	case "$I" in
		 1) HARDWARE="Linksys WRT54G/GS/GL" ;;		# brcm47xx
		 2) HARDWARE="Ubiquiti Bullet M" ;;		# ar71xx
		 3) HARDWARE="TP-LINK TL-WR1043ND v2" ;;	# ar71xx
		24) HARDWARE='TP-LINK TL-WR1043ND' ;;		# ar71xx
		 4) HARDWARE="Buffalo WHR-HP-G54" ;;		# brcm47xx
		 5) HARDWARE="SPW500V" ;;			# speedport w500v / aldi router
		 6) HARDWARE="ASUS WL-HDD" ;;			# brcm47xx
		 7) HARDWARE="ASUS WL-500g Premium V2" ;;	# brcm47xx
		 8) HARDWARE="ASUS WL-500g Premium" ;;		# brcm47xx
		 9) HARDWARE="Dell TrueMobile 2300" ;;		# brcm47xx // nvram set ModelId=WX-5565 commit
		10) HARDWARE="Ubiquiti RouterStation Pro" ;;	# ar71xx
		11) HARDWARE="4G Systems MTX-1 Board" ;;	# au1000 / meshcube
		12) HARDWARE="Buffalo WZR-HP-AG300H" ;;		# ar71xx
		13) HARDWARE="Ubiquiti Nanostation M" ;;	# ar71xx
		14) HARDWARE="Seagate FreeAgent DockStar" ;;	# kirkwood
		15) HARDWARE="TP-LINK TL-WR841N/ND v7" ;;	# ar71xx
		16) HARDWARE="SPW500V" ;;			# brcm63xx / Targa WR 500 VoIP
		17) HARDWARE="TP-LINK TL-WDR3600/4300/4310" ;;	# ar71xx
		18) HARDWARE="TP-LINK TL-WR703N v1" ;;		# ar71xx
		19) HARDWARE="TL-WDR4900 v1" ;;			# mpc85xx / vendor: tplink
		20) HARDWARE="TP-LINK TL-WR841N/ND v8" ;;	# ar71xx
		21) HARDWARE='PC Engines ALIX.2 ' ;;		# x86
		22) HARDWARE='Asus WL500GP V1' ;;		# brcm47xx -> rename
		23) HARDWARE='La Fonera 2.0N' ;;		# ramips_24kec
		25) HARDWARE='Seagate GoFlex Net' ;;		# kirkwood
		26) HARDWARE='TP-LINK Archer C7' ;;		# ar71xx
		*)
			export HARDWARE=
			return 1
		;;
	esac

	export HARDWARE
}

wireless_reghack_available()
{
	grep -q ^'=== REGHACK:' '/etc/openwrt_patches'
}

warn_when_jffs2_faulty()
{
	# jffs2: jffs2_scan_eraseblock(): Magic bitmask 0x1985 not found at 0x00160010: 0x71c7 instead
	find_all_strings_in_dmesg 'jffs2_scan_eraseblock(): Magic bitmask ' 'not found at ' && {
		log "JFFS2 faulty, please check '$DMESG' - maybe 'firstboot' can fix it"
	}
}

warn_when_jffs2_full()
{
	find_all_strings_in_dmesg 'Too few erase blocks' && {
		log "JFFS2 full"
	}
}

[ -e '/tmp/LOCKFILE_APPLY' ] && {
	log 'abort early: /tmp/LOCKFILE_APPLY exists'
	exit 1
}

[ "${USER:-root}" = 'root' ] || {
	log "[ERR] user = $USER: seems we are in cross compiling stage?"
	exit 0
}

[ "$INSTALLATION" = 'boot' ] && {
	[ -e '/overlay/upper/etc/config/system' -a -n "$( ls -1 '/overlay/upper/www/images' )" ] && {
		log "[ERR] bug detected: https://dev.openwrt.org/ticket/19564 - cleaning up and rebooting"
		rm -f /overlay/upper/www/images/*
		rm -f /overlay/upper/etc/dropbear/authorized_keys
		rm -f /overlay/upper/etc/dropbear/known_hosts
		rm -f /overlay/upper/usr/lib/opkg/info/*.postinst
		rm -f /overlay/upper/usr/lib/opkg/info/*.control

		exit 0
	}
}

[ "$( logread | grep "init: process '/bin/ash" | grep -c 'exited. Scheduling for restart.' )" -gt 10 ] && {
	# daemon.info init: starting pid 15022, tty '/dev/ttyS0': '/bin/ash --login'		// should correctly detect 'ttyS0'
	log "detect_respawing_login daemon alert deactivating ttyS0 in /etc/inittab"
	sed -i 's/^ttyS0/# ttyS0/' /etc/inittab
	kill -s HUP 1	# forced process "init" to reload it's config-file
}

DMESG='/tmp/dmesg.boot'
[ -e "$DMESG" ] || dmesg >"$DMESG"

while ! jffs2_is_ready 'check'; do {
	log "waiting for JFFS2 to be ready"
	warn_when_jffs2_faulty
	warn_when_jffs2_full && exit 0

	read -r FRESHFLASH </etc/openwrt_version
	sleep 5
} done
log "uptime now: $( uptime_in_seconds ) seconds, waiting 5sec"
[ -n "$FRESHFLASH" ] && echo "fresh flashed with $FRESHFLASH" >>/www/everlasting_syslog.txt
warn_when_jffs2_faulty

sleep 5
df | logger

INSTALLATION="$1"	# e.g. mynetwork
PROFILE_MODE="$2"	# e.g. adhoc
NODENUMBER="$3"		# e.g. 123
GATEWAY="$4"
[ "$INSTALLATION" = 'boot' ] && INSTALLATION=

# if we totally change a routers place (another network,
# also set defaults to hostname/remove packages etc.)
[ -n "$INSTALLATION" ] && {
	OLD_INSTALLATION="$( uci -q get system.@profile[0].name | cut -d'_' -f1 )"
	[ -n "$OLD_INSTALLATION" ] && {
		[ "$INSTALLATION" = "$OLD_INSTALLATION" ] || {
			uci set system.@system[0].hostname='OpenWrt'

			for SOFTWARE in mydesign mysettings sshpubkeys fff-adblock-list; do {
				opkg status "$SOFTWARE" | grep -q ^'Package:' && {
					log "[OK] network changes, removing: $SOFTWARE"
					opkg remove "$SOFTWARE"
				}
			} done
		}
	}
}

[ "$INSTALLATION" = '?' ] || {
 SIM_ARG1="$( uci -q get system.@profile[0].name | cut -d'_' -f1 )"
 SIM_ARG2="$( uci -q get system.@profile[0].name | cut -d'_' -f2 )"
 SIM_ARG3="$( uci -q get system.@profile[0].nodenumber )"

	[ -z "$SIM_ARG1" ] && {
		case "$HARDWARE" in
			'Seagate GoFlex Home')
				SIM_ARG1="$( uboot_getvar 'x_profile_name' | cut -d'_' -f1 )"
				SIM_ARG2="$( uboot_getvar 'x_profile_name' | cut -d'_' -f2 )"
				SIM_ARG3="$( uboot_getvar 'x_profile_nodenumber' )"
			;;
		esac
	}
}

while [ $( uptime_in_seconds ) -lt 120 ]; do {
	log 'no wan-default route, waiting for uptime >120 sec'
	has_default_route "$( uci -q get network.wan.ifname )" && break
	sleep 5
} done

has_default_route "$( uci -q get network.wan.ifname )" && {
	[ "$( uci get network.wan.proto )" = 'dhcp' ] && {
		SIM_ARG4='dhcp'		# auf masq=1 testen?
	}
}



#######################################
#
# enforcing a profile (this can be uncommented manually or via script) - do not change this section
#
#SIM_ARG1="olympia"
#SIM_ARG2="adhoc"
#SIM_ARG3=2		# 2,3,4,...,n (number 1 is reserved for vpn-server)
#SIM_ARG4=""
#[ "$SIM_ARG3" = "2" ] && SIM_ARG4="dhcp"
#
#######################################



[ -n "$SIM_ARG1" -a -n "$SIM_ARG2" -a -n "$SIM_ARG3" -a -z "$PROFILE_MODE" ] && {
	log "detected already set values:"
	log "INSTALLATION: $SIM_ARG1"
	log "PROFILE_MODE: $SIM_ARG2"
	log "NODENUMBER: $SIM_ARG3"
	log "GATEWAY: $SIM_ARG4"

	[ "$1" = "boot" ] || {
		echo "press <enter> to continue/reapply these values or strg+c to abort"
		read -r _
	}

	INSTALLATION=$SIM_ARG1
	PROFILE_MODE=$SIM_ARG2
	NODENUMBER=$SIM_ARG3
	GATEWAY=$SIM_ARG4
}

[ -z "$NODENUMBER" -o -z "$INSTALLATION" -o -z "$PROFILE_MODE" -o "$INSTALLATION" = "?" ] && {
	echo "Usage: $0 <installation> <adhoc|ap|hybrid> <nodenumber> <gateway|dhcp|empty>"
	echo
	echo "		 installation = {"

	grep -hs ^"	[a-z0-9|]*)" "$0.definitions.private" "$0.definitions" | sed 's/)//g' | while read -r line; do {
		echo "					$line"
	} done

	echo "				}"

	exit 1
}

case "$PROFILE_MODE" in
	ap|adhoc|hybrid)
		log "[OK] mode '$PROFILE_MODE' is valid"
	;;
	*)
		log 'abort, mode must be one of [ap|adhoc|hybrid]'
		exit 1
	;;
esac

if [ -e '/tmp/LOCKFILE_APPLY' ]; then
	log "abort: /tmp/LOCKFILE_APPLY exists"
	exit 1
else
	touch '/tmp/LOCKFILE_APPLY'
fi

[ -e '/tmp/loader' ] && . /tmp/loader		# TODO: we should totally rely on this

[ -n "$LOWMEM" ] && {
	mv -f '/tmp/CRON_IS_CAREFUL' '/tmp/CRON_IS_CAREFUL.old'
	killall crond
	for DAEMON in uhttpd olsrd sysntpd 6relayd dnsmasq ulogd; do {
		log "ending daemon: $DAEMON"
		/etc/init.d/$DAEMON stop
	} done
}

[ -z "$OLSR_METRIC" ] && OLSR_METRIC='etx_ffeth'

if   hwprobe "D-Link DIR-300 RevA1"; then
	HARDWARE="D-Link DIR-300 RevA1"
elif hwprobe "Ubiquiti Nanostation2"; then
	HARDWARE="Ubiquiti Nanostation2"
elif hwprobe "Ubiquiti Nanostation5"; then
	HARDWARE="Ubiquiti Nanostation5"
fi

[ -z "$HARDWARE" ] && {
	while try_device; do {
		grep -Fq "$HARDWARE" "$DMESG" && break
	} done
}

if [ -n "$HARDWARE" ]; then
	case "$HARDWARE" in
		'TP-LINK Archer C7')
			. /tmp/loader
			[ $( _system flash_size ) -eq 16384 ] && {
				HARDWARE="$HARDWARE v2"
			}
		;;
		'Asus WL500GP V1')
			HARDWARE='ASUS WL-500g Premium'
		;;
		"4G Systems MTX-1 Board")
			HARDWARE="T-Mobile InternetBox"	# also: '4G MeshCube'
		;;
		"SPW500V")
			HARDWARE="Speedport W500V"	# also: 'Targa WR 500 VoIP'
		;;
		"TL-WDR4900 v1")
			HARDWARE="TP-LINK $HARDWARE"
		;;
		"Ubiquiti Bullet M")
			ip address show | grep -Fq " 00:27:22:" && {
				log "is it a 'Ubiquiti Picostation M2'?"
				# HARDWARE="Ubiquiti Picostation M2"
			}
		;;
		'Seagate GoFlex Net')
			[ "$( uboot_getvar 'machid' )" = '0xd0a' ] && {
				# see https://dev.openwrt.org/ticket/14303
				HARDWARE='Seagate GoFlex Home'
			}
		;;
	esac
elif hwprobe "Ubiquiti PicoStation2"; then		# Atheros-Platform: http://www.ubnt.com/picostation
	HARDWARE="Ubiquiti PicoStation2"
elif hwprobe "Ubiquiti PicoStation5"; then		# Atheros-Platform: http://www.ubnt.com/picostation5
	HARDWARE="Ubiquiti PicoStation5"
elif grep -sq ^'loco-m-xw'$ '/tmp/sysinfo/board_name'; then
	if iw phy phy0 info | grep -q '5180 MHz'; then
		HARDWARE="Ubiquiti Nanostation loco M5"
	else
		HARDWARE="Ubiquiti Nanostation loco M2"
	fi
elif [ -e "/etc/HARDWARE" ]; then
	log "could not detect hardware, trying /etc/HARDWARE"
	read -r HARDWARE </etc/HARDWARE
else
	log "could not detect hardware, please enforce manually with a text in /etc/HARDWARE - abort"

	[ "$1" = "help" ] || exit 1
fi

HARDWARE="$( echo "$HARDWARE" | sed 's/[ ]*$//' )"	# strip trailing whitespace (see alix2)

log "detected: '$HARDWARE' and wrote to '/etc/HARDWARE' for later monitoring"
echo "$HARDWARE" >"/etc/HARDWARE"

case "$HARDWARE" in
	"Linksys WRT54"*|"Buffalo WHR-HP-G54"|"Dell TrueMobile 2300")
		rm -f /etc/modules.d/*usb*
	;;
esac


case "$PROFILE_MODE" in
	hybrid)
		PROFILE_MODE="adhoc"
		[ -e "${0}.definitions.private" ] && . "${0}.definitions.private"
		. ${0}.definitions
		PROFILE_MODE="hybrid"

		[ -z "$SSID_ENFORCED" ] && {
			SSID_ENFORCED="$INSTALLATION $NODENUMBER"
		}
	;;
	*)
		[ -e "${0}.definitions.private" ] && . "${0}.definitions.private"
		. ${0}.definitions
	;;
esac

[ -z "$CHANNEL" ] && CHANNEL=1

case "$HARDWARE" in
	"Ubiquiti Bullet M")
		[ -n "$TXPOWER" ] && {
			# https://dev.openwrt.org/browser/trunk/package/iwinfo/src/iwinfo_lib.c#L31
			TXPOWER=$(( TXPOWER - 12 ))
		}
	;;
esac


OLD_HOSTNAME="$( uci get system.@system[0].hostname )"

case "$OLD_HOSTNAME" in
	'OpenWrt'|'')
		OLD_HOSTNAME="${INSTALLATION}-${PROFILE_MODE}-${GATEWAY}-${NODENUMBER}"
		log "using new hostname $OLD_HOSTNAME"
	;;
	*)
		log "leaving hostname $OLD_HOSTNAME"
	;;
esac

echo "$OLD_HOSTNAME" >/proc/sys/kernel/hostname

_config_polipo()
{
	local net_allowed="10.0.0.0/8"		# fixme! hardcoded (restrict to HNA4?)
	local dropfile="/etc/hosts.drop"
	local cache_path="/tmp/usb0"

	cat >/etc/config/polipo <<EOF
config 'polipo' 'daemon'
	option 'daemonise' '1'
	option 'pidFile' '/var/run/polipo.pid'

config 'polipo' 'general'
	option 'enabled' '1'
	# address on which polipo will listen, 0.0.0.0 means all addresses
	option 'proxyAddress' '0.0.0.0'
	option 'proxyPort' '8123'
	list 'allowedClients' '$net_allowed'
	# how much RAM memory should Polipo use (in bytes).
	option 'chunkHighMark' '1048576'
	# enable disk cache index and serverlist of integrated polipo web interface
	#option 'disableIndexing' '0'
	#option 'disableServersList' '0'
	# disable logging to syslog
	# option 'logSyslog' '0'
	# set log file location (disabled when not set)
	option 'logFile' '$cache_path/polipo.log'
	option 'forbiddenFile' '$dropfile'
	option 'dnsQueryIPv6' 'false'
	option 'dnsUseGethostbyname' 'true'
	option 'dnsNameServer' '127.0.0.1'
	option 'dnsMaxTimeout' '1'
	option 'dnsNegativeTtl' '1'

config 'polipo' 'cache'
	# disk cache location, you should always use external storage device
	# (disabled when not set)
	option 'diskCacheRoot' '$cache_path'
	# disk cache cleanup settings
	#option 'diskCacheUnlinkTime' '20d'
	#option 'diskCacheTruncateTime' '5d'
	#option 'diskCacheTruncateSize' '3145728'
	# set to 1 if proxy is used by multiple users
	option 'cacheIsShared' '1'

config 'polipo' 'pmm'
	# poor man's multiplexing segment size to fetch
	option 'pmmSize' '8192'
EOF
}

_config_system()
{
	local NODE="$1"
	local webcam_old="$( uci -q get system.@webcam[0].storage_path )"

	echo "$OLD_HOSTNAME" >/proc/sys/kernel/hostname

	cat >/etc/config/system <<EOF
config 'system'
	option 'hostname' '$OLD_HOSTNAME'
	option 'timezone' '${TIMEZONE:-GMT0}'
	option 'cronloglevel' '9'
	option 'log_size' '16'

config 'timeserver'	# FIXME! change to: config timeserver ntp
	list server 0.openwrt.pool.ntp.org
	list server 1.openwrt.pool.ntp.org
	list server 2.openwrt.pool.ntp.org
	list server 3.openwrt.pool.ntp.org
	option enable_server 0

EOF

case "$HARDWARE" in
	"TP-LINK TL-WR1043ND")
		cat >>/etc/config/system <<EOF

config 'led' 'wlan_led'
	option name	'WLAN'
	option sysfs	'tl-wr1043nd:green:wlan'
	option trigger	'phy0rx'
EOF
	;;
	"BulletM")
		:
	;;
esac

	case "${INSTALLATION}" in
		*)
			weblogin_hide=
		;;
	esac

	cat >>/etc/config/system <<EOF

config 'weblogin'
${weblogin_hide}	option enabled	'1'
	option namespace 'capital_citys_de'
EOF

	cat >>/etc/config/system <<EOF

config 'profile'
	option name	'${INSTALLATION}_${PROFILE_MODE}'
	option nodenumber '$NODE'
	option ipsystem	'${IPSYSTEM}'

config 'vds'
	option server	'root@intercity-vpn.de:/var/www/networks/${INSTALLATION}/vds/'
	option enabled	'1'

config 'monitoring'
	option url	'http://intercity-vpn.de/networks/${INSTALLATION}'

config 'fwupdate'
	option url	'http://intercity-vpn.de/firmware'
	option mode	'testing'

config 'admin'
	option location	'$( contact location )'
	option latlon	'$( contact latlon )'
	option mail	'$( contact mail )'
	option name	'$( contact name )'
	option phone	'$( contact phone )'
	option neturl	'$( contact neturl )'

config 'vpn'
	option hostname 'weimarnetz.de'
	option ipaddr	'77.87.48.19'
EOF

	[ -n "$webcam_old" ] && {
		cat >>/etc/config/system <<EOF

config webcam
	option storage_path '$webcam_old'
EOF
	}
}

_config_softwareinstall()
{
	local service

	for service in	olsrd $( test -e '/www/SIMPLE_MESHNODE' || echo 'dnsmasq' ) \
			crashlog_apport \
			count_reboots \
			generate_kalua_loader \
			generate_netparams \
			end_boot \
			prepare_stuff \
			netfilter \
			cron.user; do {
		/etc/init.d/$service enabled || /etc/init.d/$service enable
	} done

	for service in	samba \
			siproxd \
			netserver \
			ulogd \
			cron \
			firewall; do {
		/etc/init.d/$service enabled && /etc/init.d/$service disable
	} done
}


_config_wireless()			# fixme! channels hardcoded
{
	local NODE="$1"
	local MAC htmode hwmode hwband country ht_cap ht_cap_list radiotype radiocard
	local hideht hidetx hidehwmode hidehwband
	local temp="/tmp/config_wireless.tmp"
	local driver_path distance
	local network_append=
	local default_channel="$CHANNEL"
	local pointing2device

	# only for AP-interfaces:
	local default_encryption_type="${WIFI_ENCRYPTION:-none}"	# e.g. psk2
	local default_encryption_pass="$WIFI_PASS"			# e.g. mypass
	local hideE='#'
	[ "$default_encryption_type" = 'none' ] || hideE=

	# wireless.@wifi-iface[0].encryption=psk2 wireless.@wifi-iface[0].key=31122014

	[ -e "/etc/config/wireless" ] || {
		log "omitting section wireless, wifi n/a"
		return 0
	}

	[ -e "$temp" ] && rm -f "$temp"

	[ -z "$TXPOWER" ] && hidetx="#"

	for radiocard in 0 1 2 3; do {
		[ "$( uci get wireless.radio${radiocard}.disabled )" = "1" ] && {
			uci set wireless.radio${radiocard}.disabled=0
		}
	} done

for radiocard in 0 1 2 3; do {
	# old:
	# new:
	driver_path="$( uci get wireless.radio${radiocard}.path )"		# e.g. 'platform/ath9k' or 'platform/ar231x-wmac.0'
	distance="$(    uci get wireless.radio${radiocard}.distance )"

	# check if real wifi card or only VAP/hybrid interface
	local var="wireless.@wifi-iface[$radiocard].device"
	pointing2device="$( uci get $var )"	# e.g. radio1
	[ "$( uci get wireless.${pointing2device} )" = "wifi-device" ] || continue
	[ -n "$( uci get wireless.${pointing2device}.type )" ] || continue

	radiotype="$( uci get wireless.radio${radiocard}.type )"	# e.g. 'mac80211' or 'atheros'
	[ -z "$radiotype" ] && continue

	[ $radiocard -gt 0 ] && {
		echo
		echo '### next radio ###'
		echo
		network_append="RADIO${radiocard}"
	} >>"$temp"

	log "configuring radio${radiocard} ..."

	local hide_mac="#"
	MAC="$( uci get wireless.radio${radiocard}.macaddr )"
	if [ -z "$MAC" ]; then
		[ -z "$driver_path" ] && {
			hide_mac=
			MAC="11:22:33:44:55:66"
			log "[ERR] empty mac, we set $MAC"
		}
	else
		hide_mac=
	fi

	hwband="$( uci get wireless.radio${radiocard}.band )"		# e.g. 2g or 5g

	hwmode="$( uci get wireless.radio${radiocard}.hwmode )"		# backup current state
	[ -z "$hwband" ] && hwmode="${hwmode:-11g}"
	[ "$HARDWARE" = 'UML' -a "$radiocard" = '0' ] && hwmode='11n'	# hwsim has 2 x dualcard

	case "$hwmode" in
		11g|11a)
			hideht="#"
		;;
	esac

	htmode="$( uci get wireless.radio${radiocard}.htmode )"
	case "$htmode" in	# maybe switched off by user
		'')
			hideht="#"
		;;
	esac

	ht_cap_list="$( uci get wireless.radio${radiocard}.ht_capab )"	# backup current state

	ht_cap_uci_output()
	{
		for ht_cap in $ht_cap_list; do {
			echo "	list ht_capab	'$ht_cap'"
		} done
	}

	bssid_wellformed()
	{
		local channel="$1"			# e.g. 161
		local bssid="${2:-02:ca:ff:ee:ba:be}"

		case "$INSTALLATION" in
			liszt28|ffweimar)
				[ "$channel" = '5' ] && {
					log "[OK] enforcing special value '02:ca:ff:ee:ba:be' for $INSTALLATION"
					echo '02:ca:ff:ee:ba:be'
					return 0
				}
			;;
		esac

		bssid="$( echo "$bssid" | cut -b 1-11 )"	# 02:be:ef:ca:ff:ee -> 02:be:ef:ca

		if [ "$channel" -lt 100 ]; then
			if [ "$channel" -lt 10 ]; then
				echo "${bssid}:00:0${channel}"
			else
				echo "${bssid}:00:$channel"
			fi
		else
			# channel 161 -> bssid ends with ..:01:61"
			echo "${bssid}:0$( echo "$channel" | cut -b 1 ):$( echo "$channel" | cut -b 2-3 )"
		fi
	}

	# detect 5ghz-mode, those are working initially:
	#
	# channel  36 (5180mhz) HT40+| --  |NOHT
	# channel  40 (5200mhz) HT40+|HT40-| --
	# channel  44 (5220mhz) HT40+|HT40-|NOHT
	# channel  48 (5240mhz)  --  |HT40-|NOHT
	# channel 153 (5765mhz)  --  |HT40-|NOHT
	# channel 157 (5785mhz) HT40+|HT40-
	# channel 161 (5805mhz) HT40+|NOHT
	#
	# with jow's reghack:
	# 36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 149 153 157 161 165

	CHANNEL="$default_channel"

	get_wifi_band()
	{
		case "$hwband" in
			2g) echo 'g' && return ;;
			5g) echo 'a' && return ;;
		esac

		case "$hwmode" in
			11na|11a)
				echo 'a'
			;;
			*)
				echo 'g'
			;;
		esac
	}

	case "$( get_wifi_band )" in
		a)
			local channel_now="$( uci get wireless.radio${radiocard}.channel )"
			local var="wireless.@wifi-iface[$radiocard].bssid"
			local bssid_now="$( uci get $var )"

			if [ "$bssid_now" = "$( bssid_wellformed "$channel_now" "$BSSID" )" ]; then
				log "[OK] using already configured channel $channel_now"
				CHANNEL="$channel_now"
			else
				CHANNEL=36
			fi

			BSSID="$( bssid_wellformed "$CHANNEL" "$BSSID" )"

			log "[OK] using mode 801.$hwmode now and channel $CHANNEL with bssid: $BSSID"

			case "$MCAST_RATE" in
				1000|2000|5500)
					log "[OK] forcing mcast_rate to lowest basic-rate: 6000"
					MCAST_RATE="6000"
				;;
			esac
		;;
		*)
			BSSID="$( bssid_wellformed "$CHANNEL" "$BSSID" )"
		;;
	esac

	case "$htmode" in
		*vht*|*VHT*)
		;;
		*)
			wireless_reghack_available || {
				case "$CHANNEL" in
					36|37|38|39|40|149|153|161) htmode="HT40+" ;;
					44|157) htmode="HT40-" ;;
					1|2|3|4|5|6) htmode="HT40+" ;;
					   12|13|14) htmode="HT20" ;;		# fixme!
						  *) htmode="HT40-" ;;
				esac
			}

			case "$PROFILE_MODE" in
				hybrid)
					htmode="HT20"
				;;
			esac

			case "$hwmode" in
				11g)
					htmode="HT20"
				;;
			esac

			local hide_noscan
			case "$htmode" in
				"HT20")
					hide_noscan="#"
				;;
			esac
		;;
	esac

	[ "$hideht" = "#" ] && hide_noscan="#"

	local chanbw="$( uci get wireless.radio${radiocard}.ath9k_chanbw )$( uci get wireless.radio${radiocard}.chanbw )"	# old/new method
	case "$chanbw" in
		5|10)
			hide_chanbw=
		;;
		*)
			chanbw=20
			hide_chanbw="#"
		;;
	esac

	if   wireless_reghack_available; then
		country='US'
	elif [ -e "/etc/init.d/apply_profile.reghack.elf" ]; then
		country="US"
	elif [ $CHANNEL -gt 13 -a "$( get_wifi_band )" = 'g' ]; then
		country="JP"
	elif [ $CHANNEL -gt 11 -a "$( get_wifi_band )" = 'g' ]; then
		country="DE"
	else
		country="US"
	fi

	case "$country" in
		"US"*)
			[ -e "/etc/init.d/apply_profile.reghack.elf" ] && {
				log "patching ath9k on ar71xx with jow's reghack"
				cp /lib/modules/*/ath.ko /tmp
				cp /lib/modules/*/cfg80211.ko /tmp

				/etc/init.d/apply_profile.reghack.elf /tmp/ath.ko && {
					/etc/init.d/apply_profile.reghack.elf /tmp/cfg80211.ko && {
						log "patching fine, moving to rootfs"
						if mv -f /tmp/*.ko /lib/modules/*/ ; then
							rm -f "/etc/init.d/apply_profile.reghack.elf"
						else
							log "oops, moving to rootfs went wrong - rolling back"
							cp /rom/lib/modules/*/ath.ko /lib/modules/*/
							cp /rom/lib/modules/*/cfg80211.ko /lib/modules/*/
						fi
					}
				}
			}
		;;
	esac

	case "$PROFILE_MODE" in
		hybrid)
			local ssid_adhoc='bb'			# fixme! work with 'hidden'
			local ssid_ap="$( uci get wireless.@wifi-iface[$(( radiocard + 1 ))].ssid )"
			[ -z "$ssid_ap" ] && ssid_ap="${INSTALLATION} $NODE"

			cat >>"$temp" <<EOF
config wifi-device radio${radiocard}
	option type	$radiotype
	option country	$country
	option channel	$CHANNEL
$hide_chanbw	option chanbw	$chanbw		# since r32596
$hide_mac	option macaddr	$MAC
	option frag	off
$hidetx	option txpower	$TXPOWER
	option beacon_int 1000
${hide_noscan}	option noscan	1
$( test -n "$distance" && echo "	option distance '$distance'" )
EOF

			[ -n "$driver_path" ] && echo "	option path '$driver_path'" >>"$temp"

			hidehwband=
			[ -z "$hwband" ] && hidehwband='#'

			hidehwmode=
			[ -z "$hwmode" ] && hidehwmode='#'

			cat >>"$temp" <<EOF
${hidehwband}	option band	${hwband:-???}
${hidehwmode}	option hwmode   ${hwmode:-???}
${hideht}	option htmode   $htmode
$( ht_cap_uci_output )
EOF

	case "$HARDWARE" in
		"Buffalo WHR-HP-G54")
			{
				echo '	option rxantenna 1'
				echo '	option rxantenna 1'
			} >>"$temp"
		;;
		"Linksys WRT54G"*|"ASUS WL-500g Premium")
			{
				echo '	option rxantenna 0'
				echo '	option rxantenna 0'
			}
		;;
	esac

			[ -z "$BSSID" ] && BSSID="$( bssid_wellformed "$CHANNEL" )"

			cat >>"$temp" <<EOF

config wifi-iface
	option device	radio${radiocard}
	option network	wlanadhoc${network_append}
	option mode	adhoc
	option bssid	'$BSSID'
	option ssid	'${ssid_adhoc}'
	option mcast_rate ${MCAST_RATE}
#	option bintval	1000

config wifi-iface
	option device	radio${radiocard}
	option network	wlan${network_append}
	option encryption '$default_encryption_type'
	option mode	ap
$hideE	option encryption '$default_encryption_type'
$hideE	option key '$default_encryption_pass'
	option ssid	'${ssid_ap}'
EOF
		;;
		ap*)
			local var="wireless.@wifi-iface[$radiocard].ssid"
			local old_essid="$( uci get $var )"
			local new_essid="${INSTALLATION} $NODE"

			[ -n "$SSID_ENFORCED" ] && {
				new_essid="$SSID_ENFORCED"
			}

			case "$old_essid" in
				*[0-9])
					new_essid="$old_essid"
				;;
				*")")
					new_essid="$old_essid"
				;;
				*" "*)
					new_essid="$old_essid"
				;;
				LaLaBa*|*Dach)
					new_essid="$old_essid"
				;;
			esac

			cat >>"$temp" <<EOF
config wifi-device radio${radiocard}
	option type	$radiotype
	option country	$country
$hidetx	option txpower	$TXPOWER
	option channel	$CHANNEL
$hide_mac	option macaddr	$MAC
	option frag	off
${hide_noscan}	option noscan	1
$( test -n "$distance" && echo "	option distance '$distance'" )
EOF

			[ -n "$driver_path" ] && echo "	option path '$driver_path'" >>"$temp"

	grep -q ^"b43 " "/proc/modules" && cat >>"$temp" <<EOF
	option bitrates '6 9 12 18 24 36 48 54'
EOF

			cat >>"$temp" <<EOF
	option hwmode   $hwmode
${hideht}	option htmode   $htmode
$( ht_cap_uci_output )
EOF

			cat >>"$temp" <<EOF

config wifi-iface
	option device	radio${radiocard}
	option network	wlan${network_append}
	option mode	ap
	option ssid	'${new_essid}'
$hideE	option encryption '$default_encryption_type'
$hideE	option key '$default_encryption_pass'
EOF
		;;
		*)
			local new_essid="bb"

			case "${INSTALLATION}" in
				aschbach*) new_essid="Berghotel" ;;
				ffweimar*) new_essid="weimarnetz" ;;
			esac

			cat >>"$temp" <<EOF
config wifi-device radio${radiocard}
	option type	$radiotype
	option country	$country
	option channel	$CHANNEL
$hide_chanbw	option chanbw	$chanbw		# since r32596
$hide_mac	option macaddr	$MAC
	option frag	off
$hidetx	option txpower	$TXPOWER
	option beacon_int 1000
${hide_noscan}	option noscan	1
$( test -n "$distance" && echo "	option distance '$distance'" )
EOF

			[ -n "$driver_path" ] && echo "	option path '$driver_path'" >>"$temp"

	grep -q ^"b43 " "/proc/modules" && cat >>"$temp" <<EOF
	option bitrates '6 9 12 18 24 36 48 54'
EOF

			cat >>"$temp" <<EOF
	option hwmode	$hwmode
${hideht}	option htmode	$htmode
$( ht_cap_uci_output )
EOF

			[ -z "$BSSID" ] && BSSID="$( bssid_wellformed "$CHANNEL" )"

			cat >>"$temp" <<EOF

config wifi-iface
	option device	radio${radiocard}
	option network	wlan${network_append}
	option mode	adhoc
	option bssid	'$BSSID'
	option ssid	'${new_essid}'
	option mcast_rate ${MCAST_RATE}
#	option bintval	1000
EOF
		;;
	esac

} done

	mv -f "$temp" /etc/config/wireless
}

_config_mail()
{
	cat >/etc/config/mail <<EOF
config pop3
	option username	'$POP3_USERNAME'
	option password	'$POP3_PASSWORD'
	option server	'pop.gmx.net'
	option port	'110'

config smtp
	option server	'mail.gmx.net'
	option port 	'25'
	option auth	'pop-before-smtp'
	option mail	'wlan-assistance@gmx.de'
	option name	'Ticket-Assistent'
EOF
}

_config_sms()
{
	cat >/etc/config/sms <<EOF
config sms
	option username	'$SMS77_USERNAME'
	option password	'$SMS77_PASSWORD'
	option post	''
	option phonebook	''
EOF
}

_config_network()
{
	local NODE="$1"
	local PROTO LANDEV WANDEV

	case "$HARDWARE" in
		"Dell TrueMobile 2300")
			LANMAC="00:90:4b:39:7b:5e"	# fixme!
			WANMAC="00:90:4b:39:7b:5f"	# fixme!
		;;
	esac

	LANDEV="$( uci get network.lan.ifname )"
	WANDEV="$( uci get network.wan.ifname )"

	if [ "$GATEWAY" = "dhcp" ]; then
		PROTO="dhcp"

		[ -n "$LANDEV" -a -z "$WANDEV" ] && {
			log "swapping LANDEV with WANDEV, we are on singleport machine"
			WANDEV="$LANDEV"
			LANDEV=
		}
	else
		PROTO="static"
	fi

	# see 9d88ce9279c0e54ea53508d7636cdfdc8fc147be, delete really old network-sections for e.g. multiple wifi-ifs
	for section in $( uci show network | grep "=interface"$ | grep -v "6=interface"$ | grep -v "loopback=interface"$ | cut -d'=' -f1 ); do {
		uci delete $section
	} done
	_log it uci_commit daemon alert 'network: remove old sections'
	uci commit network

	vpn_state()
	{
		case "$NETWORK" in
			liszt28*|ffweimar*|paltstadt*|palais*)
				echo '0'
			;;
			*)
				echo '1'
			;;
		esac
	}

		# TODO: generate on the fly
		cat >>/etc/config/network <<EOF
config interface 'innercityVPN'
	option disabled '$( vpn_state )'
	option ifname 'tap0'
	option proto 'static'
	option ipaddr '$(  _ipsystem getvar WIFIVPNCLIENTADR )'
	option netmask '255.255.255.252'
	option mtu '1420'

EOF

	[ -n "$LANDEV" ] && {
		cat >>/etc/config/network <<EOF

config 'interface' 'lan'
	option 'ifname'   '$LANDEV'
$( test -n "$LANMAC" && echo "	option 'macaddr' '$LANMAC'" )
	option 'proto'    'static'
	option 'ipaddr'   '$( _ipsystem getvar 'LANADR' $NODE )'
	option 'netmask'  '$( _ipsystem getvar 'LANMSK' $NODE )'

EOF
	}

	if [ -z "$WANDEV" ]; then
			:		# no wandev/singleport
	else
		local hide_gateway="#"
		local wan_ipaddr="$(  _ipsystem getvar 'WANADR' $NODE )"
		local wan_netmask="$( _ipsystem getvar 'WANMSK' $NODE )"
		local wan_gateway=
		local username password hideip wan_dns

		case "${NODE}_${INSTALLATION}" in
			2_ibfleesensee)
				wan_ipaddr='62.153.102.43'
				wan_netmask='255.255.255.248'
				wan_gateway='62.153.102.41'
			;;
			2_berlinle)
				wan_ipaddr="192.168.115.123"
				wan_netmask="255.255.255.0"
				wan_gateway="192.168.115.9"
			;;
			2_olympia)
				wan_ipaddr="192.168.178.21"
				wan_netmask="255.255.255.0"
				wan_gateway="192.168.178.1"
			;;
			2_boltenhagendh)
				wan_ipaddr="62.156.187.2"
				wan_netmask="255.255.255.248"
				wan_gateway="62.156.187.1"
			;;
			2_castelfalfi)
				wan_ipaddr="31.195.132.133"
				wan_netmask="255.255.255.224"
				wan_gateway="31.195.132.129"
			;;
			22_adagio)
				wan_ipaddr="192.168.2.102"
				wan_netmask="255.255.255.0"
				wan_gateway="192.168.2.1"
			;;
			3_extrawatt)
				wan_ipaddr="192.168.2.100"
				wan_netmask="255.255.255.0"
				wan_gateway="192.168.2.1"
			;;
			6_monami)
				wan_ipaddr="192.168.2.10"
				wan_netmask="255.255.255.0"
				wan_gateway="192.168.2.1"
			;;
			7_monami)
				wan_ipaddr="192.168.2.102"
				wan_netmask="255.255.255.0"
				wan_gateway="192.168.2.1"
			;;
			2_versiliaje)
				wan_ipaddr="192.168.178.21"
				wan_netmask="255.255.255.0"
				wan_gateway="192.168.178.1"
			;;
			119_satama)
				wan_ipaddr="192.168.2.101"
				wan_netmask="255.255.255.0"
				wan_gateway="192.168.2.1"
			;;
			3_galerie)
				wan_ipaddr="192.168.1.9"
				wan_netmask="255.255.255.0"
				wan_gateway="192.168.1.1"
			;;
			2_hotello-B01)
				wan_ipaddr="10.31.24.1"
				wan_netmask="255.255.255.0"
				wan_gateway="10.31.24.254"
			;;
			2_hotello-K80)
				wan_ipaddr="10.31.25.1"
				wan_netmask="255.255.255.0"
				wan_gateway="10.31.25.254"
			;;
			2_hotello-H09)
				wan_ipaddr="10.31.22.1"
				wan_netmask="255.255.255.0"
				wan_gateway="10.31.22.254"
			;;
			2_aschbach)
				wan_ipaddr="192.168.166.100"
				wan_netmask="255.255.255.0"
				wan_gateway="192.168.166.254"
			;;
			6_leonardo|2_schoeneck)
				PROTO="dhcp"
			;;
			50_ejbw)
				wan_ipaddr='172.17.0.2'
				wan_netmask='255.255.252.0'
				wan_gateway='172.17.0.1'
				wan_dns='172.17.0.21'
			;;
			254_rehungen)
				wan_ipaddr="109.73.30.34"
				wan_netmask="255.255.255.252"
				wan_gateway="109.73.30.33"
				wan_dns="109.73.31.212"
			;;
			2_abtpark)
				wan_ipaddr='192.168.178.21'
				wan_netmask='255.255.255.0'
				wan_gateway='192.168.178.1'
			;;
		esac

		[ -n "$wan_gateway" ] && {
			GATEWAY='yes'		# for HNA4/olsrd
			PROTO='static'
			hide_gateway=
		}

		[ "$PROTO" = 'dhcp' ] && {
			GATEWAY='yes'		# for HNA4/olsrd
		}

		[ -n "$PPPOE_USERNAME" -a -n "$PPPOE_PASSWORD" ] && {
			PROTO='pppoe'
			GATEWAY='yes'			# for HNA4/olsrd
			username="$PPPOE_USERNAME"
			password="$PPPOE_PASSWORD"
			hide_gateway=
			hideip='true'
		}

		cat >>/etc/config/network <<EOF

config 'interface' 'wan'
	option 'ifname' '$WANDEV'
$( test -n "$WANMAC" && echo "	option 'macaddr' '$WANMAC'" )
$( test -n "$wan_dns" && echo "	option 'wan_dns' '$wan_dns'" )
	option 'proto' '$PROTO'
	option 'dyndns' '$DYNDNS'
${hideip:+#}	option 'ipaddr'	 '$wan_ipaddr'
${hideip:+#}	option 'netmask' '$wan_netmask'
$hide_gateway	option 'gateway' '$wan_gateway'
${username:+	option 'username' '$username'}
${password:+	option 'password' '$password'}
${password:+	option 'authfail' '1'	# since r33291}
EOF
	fi

	[ "$HARDWARE" = 'PC Engines ALIX.2' ] && {
		cat >>/etc/config/network <<EOF

config 'interface' 'management'
	option 'ifname'   'eth2'
	option 'proto'    'static'
	option 'ipaddr'   '192.168.1.1'
	option 'netmask'  '255.255.255.252'
EOF
	}

	local radiocard
	local network_append

	ipv4address_plus_x()
	{
		local ip="$1"
		local x="$2"

		local oldIFS="$IFS"; IFS='.'; set -- $ip; IFS="$oldIFS"
		echo "$1.$2.$3.$(( $4 + x ))"
	}


for radiocard in 0 1 2 3; do {

	[ $radiocard -gt 0 ] && {
		network_append="RADIO${radiocard}"
	}

	grep "option network" "/etc/config/wireless" | grep -q "wlan${network_append}" || continue

	local wlan_ipaddr wlan_netmsk wlan_ifname hide_wifi
	local alias_ipaddr alias_netmask alias_network
	local hide="#"

	case "$( uci get wireless.radio0.type )" in
		mac80211)
			wlan_ifname="wlan0"
		;;
		atheros)
			wlan_ifname="ath0"
		;;
		*)
			wlan_ifname="wlan0"
		;;
	esac

	wlan_ipaddr="$( _ipsystem getvar 'WIFIADR' $NODE )"

	### radiocard-0
	# adhoc = .1	adhoc or ap = .1
	# ap    = .2
	### radiocard-1
	# adhoc = .3	adhoc or ap = .3
	# ap    = .4
	### radiocard-2
	# adhoc = .5	adhoc or ap = .5
	# ap    = .6

	if grep "option network" "/etc/config/wireless" | grep -q "wlanadhoc${network_append}"; then
		local ip_1stIF_addvalue=$(( ((radiocard + 1) * 2 )     - 1 ))
		local ip_2ndIF_addvalue=$(( ((radiocard + 1) * 2 ) - 1 - 1 ))
		wlan_netmsk="$( _ipsystem getvar 'WIFI_DHCP_PRE' $NODE )"
	else
		local ip_1stIF_addvalue=$(( ((radiocard + 1) * 2 ) - 1 - 1 ))
		wlan_netmsk="$( _ipsystem getvar 'WIFI_PRE' $NODE )"
	fi

	cat >>/etc/config/network <<EOF

${hide_wifi}config 'interface' 'wlan${network_append}'
#${hide_wifi}	option 'ifname'	'$wlan_ifname'
${hide_wifi}	option 'proto'	'static'
${hide_wifi}	option 'ipaddr'	 '$( ipv4address_plus_x "$wlan_ipaddr" "$ip_1stIF_addvalue" )'
${hide_wifi}	option 'netmask' '$( _net cidr2mask "$wlan_netmsk" )'

EOF

	grep "option network" "/etc/config/wireless" | grep -q "wlanadhoc${network_append}" || continue

	wlan_netmsk="$( _ipsystem getvar 'WIFI_PRE' $NODE )"

	cat >>/etc/config/network <<EOF

${hide_wifi}config 'interface' 'wlanadhoc${network_append}'
#${hide_wifi}	option 'ifname'	'$wlan_ifname'
${hide_wifi}	option 'proto'	'static'
${hide_wifi}	option 'ipaddr'	 '$( ipv4address_plus_x "$wlan_ipaddr" "$ip_2ndIF_addvalue" )'
${hide_wifi}	option 'netmask' '$( _net cidr2mask "$wlan_netmsk" )'

EOF


} done

	case "${NODE}_${INSTALLATION}" in
		'348_liszt28'*)
			GATEWAY='yes'
			alias_network='lan'
			alias_ipaddr='192.168.171.60'
			alias_netmask='255.255.255.0'
			alias_gateway='192.168.171.1'		# LAN_GATEWAY
		;;
		'222_fparkssee'*)
			GATEWAY='yes'
			alias_network="lan"
			alias_ipaddr="192.168.101.222"
			alias_netmask="255.255.255.0"
			alias_gateway="192.168.101.112"		# 250 = office_gw
		;;
		'8_rehungen'*)
			alias_network="lan"
			alias_ipaddr="10.1.0.8"
			alias_netmask="255.255.255.255"
			alias_gateway=
		;;
	esac

	[ -n "$alias_ipaddr" ] && hide=

	cat >>/etc/config/network <<EOF
${hide}config 'alias'
$hide	option 'interface' '${alias_network:-wlan}'
$hide	option 'proto' 'static'
$hide	option 'ipaddr' '$alias_ipaddr'
$hide	option 'netmask' '${alias_netmask:-255.255.255.255}'
$( test -n "$alias_gateway" && echo "	option 'gateway' '$alias_gateway'" )
EOF
}

_config_dhcp()			# domain = .olsr
{
	local NODE="$1"
	local wan_dns="$( uci get network.wan.dns )"
	local hide

	case "${NODE}_${INSTALLATION}" in
		8_rehungen*)
			hide='#'
			DNSSERVER='10.10.254.33'
		;;
	esac

	[ -n "$wan_dns" ] && DNSSERVER="$wan_dns"

	cat >/etc/config/dhcp <<EOF
config dnsmasq
	option logqueries	0	# show in syslog
	option cachesize	100	# query with 'kill -s USR1 \$( pidof dnsmasq ); logread | tail -n8'
	option domainneeded	0	# forward queries without dots
	option boguspriv	1
	option filterwin2k	0	# enable for dial on demand
	option localise_queries	1
	option rebind_protection 0	# disable if upstream must serve RFC1918 addresses
	option rebind_localhost 0	# enable for RBL checking and similar services
	# list rebind_domain example.lan # whitelist RFC1918 responses for domains
	option local	'/lan/'
	option domain	'lan'
	option expandhosts	1
	option nonegcache	0
	option authoritative	1
	option readethers	1
	option leasefile	'/tmp/dhcp.leases'
	option resolvfile	'/tmp/resolv.conf.auto'
	list addnhosts		'/var/run/hosts_olsr'
	list addnhosts		'/etc/local.hosts'
	list server 		'$DNSSERVER'
	# list server		'/mycompany.local/1.2.3.4'
	# option nonwildcard	1
	# list interface	br-lan
$hide	list notinterface	wan
	option dhcpscript	'/etc/dhcp-script.d/10dhcpscript'

config dhcp lan
	option interface	lan
	option start 		$( _ipsystem getvar 'LANDHCPSTART' $NODE )
	option limit		$( _ipsystem getvar 'LANDHCPNUM' $NODE )
	option leasetime	2h
	option force		1
	option ignore		${DHCP_IGNORE_LAN:-0}

config dhcp wlan
	option interface	wlan
	option start 		$( _ipsystem getvar 'WIFIDHCPSTART' $NODE )
	option netmask		$( _net cidr2mask "$( _ipsystem getvar 'WIFI_DHCP_PRE' $NODE )" )	# maybe lower than wifimask
	option limit		$( _ipsystem getvar 'WIFIDHCPNUM' $NODE )				# fixme! better: 21
	option leasetime	1h
	option force		1
	option ignore		${DHCP_IGNORE_WLAN:-0}

config dhcp wan
	option interface	wan
	option ignore		1
EOF
}

_config_olsrd()		# example here: http://olsr.org/git/?p=olsrd.git;a=blob;f=files/olsrd.conf.default.full
{
	local speed="${OLSR_SPEED:-6}"
	local fisheye=1
	local slave interface plugin_name plug interface_mode interface_comment
	local hna_net hna_mask
	local conf='/etc/config/olsrd'

	if [ -z "$GATEWAY" -a "$PROFILE_MODE" = 'ap' ]; then
		slave=1
	else
		slave=0
	fi

	hna_net="$(  _ipsystem getvar 'OLSR_HNA' | cut -d'/' -f1 )"
	hna_mask="$( _ipsystem getvar 'OLSR_HNA' | cut -d'/' -f2 )"
	hna_mask="$( _net cidr2mask "$hna_mask" )"

	usable_wifi_networks()
	{
		local i=0

		while name="$( uci -q get "wireless.@wifi-iface[$i].network" )"; do {
			[ "$( uci -q get "wireless.@wifi-iface[$i].mode" )" = 'adhoc' ] && {
				echo "$name"
			}

			i=$(( i + 1 ))
		} done
	}

	usable_interfaces()
	{
		local landev='lan'
		local wandev='wan'

		[ -z "$( uci get network.wan.ifname )" ] && wandev=

		[ "$( uci get network.wan.proto )" = 'static' ] || {
			case "$NETWORK" in
				'ejbw'*)	# allow: node 50
				;;
				*)
					# only olsr on wan, if no pppoe/dhcp
					# hint: we must be sure, that network-section is already written
					wandev=
				;;
			esac
		}

		echo "$landev $wandev"
		usable_wifi_networks

		uci -q get 'network.innercityVPN' >/dev/null && echo 'innercityVPN'
	}

	output_main_ip()
	{
		uci -q get 'network.lan.ipaddr' && return 0
		uci -q get 'network.wan.ipaddr' && return 0

		echo '0.0.0.0'
	}


	show_speed()
	{
		# speed macro usable since 2013-apr
		# https://github.com/openwrt-routing/packages/commit/34e1ff5702372099599f764d272069ba914661c4
		if grep -sq 'sven-ola' '/etc/init.d/olsrd' '/lib/functions/olsrd.sh'; then
			cat <<EOF
	option speed 			'$speed'
EOF
		else
			local hello_interval tc_interval

			hello_interval=$(( speed / 2 + 1 ))

			if [ "$fisheye" = '1' ]; then
				tc_interval=$(( speed / 2 ))
				[ "$tc_interval" = '0' ] && tc_interval=1
			else
				tc_interval=$(( speed * 2 ))
			fi

			cat <<EOF
	option HelloInterval		'$hello_interval.0'		# vals for speed $speed
	option HelloValidityTime	'$(( speed * 25 )).0'
	option TcValidityTime		'$(( speed * 100 )).0'
	option TcInterval		'$tc_interval.0'
	option MidInterval		'$(( speed * 5 )).0'
	option MidValidityTime		'$(( speed * 100 )).0'
	option HnaInterval		'$(( speed * 2 )).0'
	option HnaValidityTime		'$(( speed * 25 )).0'
EOF
		fi
	}


	cat >"$conf" <<EOF
config olsrd
	option MainIp			'$( output_main_ip )'
	option DebugLevel		'0'		# 0...9
	option ClearScreen		'no'		# start with -dispout
	option AllowNoInt		'yes'
	option IpVersion		'4'
	option FIBMetric		'flat'		# approx, correct, flat
	option Willingness		'7'
	option TcRedundancy		'2'
	option LinkQualityFishEye	'$fisheye'
	option LinkQualityAlgorithm	'$OLSR_METRIC'	# etx_ff, etx_ffeth, etx_float, etx_fpm
	option MprCoverage		'7'
#	option RtTable			'111'
#	option RtTableDefault		'254'		# cat /etc/iproute2/rt_tables

config meta
	option hnaslave			'$slave'
EOF

	for interface in $( usable_interfaces ); do {
		cat >>"$conf" <<EOF

config Interface
	list   interface		'$interface'
	option Ip4Broadcast		'255.255.255.255'
$( show_speed )
EOF
		[ "$OLSR_METRIC" = 'etx_ffeth' ] && {
			case "$interface" in
				lan|wan)
					interface_mode='ether'
					interface_comment='enforces cost of 0.100'
				;;
				*)
					interface_mode='mesh'
					interface_comment='uses normal cost-calculation / default'
				;;
			esac

			cat >>"$conf" <<EOF
	option Mode			'$interface_mode'		# $interface_comment
EOF
		}
	} done

	plug='true'		# via config_get_bool: 0 or <empty> -> ignore:false -> use it | 1 or 'true' = do not load
	plugin_name="$( _olsr plugin_filename_get 'txtinfo' )" && plug=
	cat >>"$conf" <<EOF

config LoadPlugin
	option ignore		'$plug'
	option library		'$plugin_name'
	option accept		'0.0.0.0'
	option port		'2006'

EOF

	plug='true'
	plugin_name="$( _olsr plugin_filename_get 'nameservice' )" && plug=
	cat >>"$conf" <<EOF
config LoadPlugin
	option ignore		'$plug'
	option library		'$plugin_name'

EOF

	plug='true'	# default: inactive
	plugin_name="$( _olsr plugin_filename_get 'jsoninfo' )"
	cat >>"$conf" <<EOF
config LoadPlugin
	option ignore		'$plug'
	option library		'$plugin_name'
	option accept		'0.0.0.0'
	option port		'9090'

EOF

	plug='true'	# default: inactive
	plugin_name="$( _olsr plugin_filename_get 'arprefresh' )"
	cat >>"$conf" <<EOF
config LoadPlugin
	option ignore		'$plug'
	option library		'$plugin_name'

EOF

	plug='true'	# default: inactive
	plugin_name="$( _olsr plugin_filename_get 'watchdog' )"
	cat >>"$conf" <<EOF
config LoadPlugin
	option ignore		'$plug'
	option library		'$plugin_name'

EOF

	plug='true'	# default: inactive
	plugin_name="$( _olsr plugin_filename_get 'dyn_gw' )"
	cat >>"$conf" <<EOF
config LoadPlugin
	option ignore		'$plug'
	option library		'$plugin_name'
	option CheckInterval	'6000'		# [msec]
	option PingInterval	'40'		# [sec]
	option Ping		'8.8.8.8'
	option Ping		'141.1.1.1'

EOF

	cat >>"$conf" <<EOF
config Hna4
        option netaddr		'$hna_net'
        option netmask		'$hna_mask'

EOF

	[ -n "$GATEWAY" ] && {
		cat >>"$conf" <<EOF
config Hna4
        option netaddr		'0.0.0.0'
        option netmask		'0.0.0.0'

EOF
	}
}

[ -e /etc/init.d/apply_profile.regulatory.bin ] && {
	rm -f "/usr/lib/crda/regulatory.bin"
	if ln -s "/etc/init.d/apply_profile.regulatory.bin" "/usr/lib/crda/regulatory.bin"; then
		log "[OK] installed new/magic regulatory.bin in /usr/lib/crda"
	else
		log "[ERR] failed to install regulatory.bin in /usr/lib/crda"
	fi
}

[ -e '/etc/kalua_init' ] && {
	log "[OK] building kalua-loader"
	[ -e '/tmp/loader' ] || /etc/kalua_init "$0"
	. /tmp/loader
	_netparam check		# it's essential for ipsystem()
	unset -f _; . /tmp/loader
	. /tmp/loader

	[ -n "$LOWMEM" -a "$PROFILE_MODE" = "adhoc" ] && {
		log "[OK] marking this node for mode SIMPLE_MESHNODE"
		touch "/www/SIMPLE_MESHNODE"
	}
}

[ -e "/etc/init.d/apply_profile" -a -n "$( uci changes )" ] && {
	mv -f /tmp/.uci /tmp/.uci_inactiv
}

for SECTION in softwareinstall system mail wireless network dhcp olsrd sms polipo; do {
	log "....working on section '$SECTION'"
	_config_$SECTION "$NODENUMBER"
	log "[ok] ready with section '$SECTION'"
} done

[ -n "$CGMINER_POOL_URL" ] && {
	log "working on cgminer"

	cat >'/etc/config/cgminer' <<EOF
package 'cgminer'

config 'cgminer' 'default'
	option 'pool1url'	'$CGMINER_POOL_URL'
	option 'pool1user'	'$CGMINER_POOL_USER'
	option 'pool1pw'	'$CGMINER_POOL_PASS'
	option 'api_allow'	'W:127.0.0.1'
	option 'more_options'	'--quiet'
EOF
}

# webserver-related stuff
uci set uhttpd.main.index_page="cgi-bin-404.sh"
uci set uhttpd.main.error_page="/cgi-bin-404.sh"
uci set uhttpd.main.config="/etc/httpd.conf"
uci set uhttpd.main.interpreter=".sh=/bin/ash"
uci set uhttpd.main.max_requests="1"
# uci set uhttpd.main.script_timeout=5			// fixme! needs testing
# uci set uhttpd.main.network_timeout=5
if [ -e "/usr/lib/uhttpd_tls.so" -o -e "/usr/lib/opkg/info/uhttpd-mod-tls.list" ]; then
	uci set uhttpd.main.listen_https="0.0.0.0:443"
else
	uci delete uhttpd.main.listen_https
fi
_log it uci_commit daemon alert 'uhttpd: added fundamental settings'
uci commit uhttpd

# disable signature-check for now:
grep -q ^'option check_signature' '/etc/opkg.conf' && {
	sed -i 's/^option check_signature/# option check_signature/' '/etc/opkg.conf'
}

. /tmp/loader

jffs2_is_ready 'check' && {
	# TODO: ugly workaround and likely unneeded after: reboot-3760-g4475da9
	while [ $( uptime_in_seconds ) -lt 240 ]; do _log sleep jffs_really_writable 10 step 10 ; done

	has_default_route && {
		_ssh sanitize_and_cleanup_keys
		[ -e '/tmp/REGISTRATED' ] && rm -f '/tmp/REGISTRATED'
		_watch random_node_id
	}
}

[ -d '/tmp/.uci_inactiv' ] && {
	# old uci changes
	mv -f /tmp/.uci_inactiv /tmp/.uci
}

# TODO: keep somehow, otherwise it's lost e.g. on jffs2-only or ext4
[ -e '/etc/init.d/apply_profile' ] && {
	rm -f '/etc/init.d/apply_profile'
}

sync
echo
echo "[OK] READY/sync'ed - now type: reboot && exit or"
echo '     activate new config without reboot with:'
echo '     /rom/etc/init.d/apply_profile services_refire'
[ -n "$FAILSAFE" ] && echo "you are in FAILSAFE mode, try 'reboot -f && exit'"
exit 0
# END
